<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MATH MASTER | Serverless P2P Edition</title>
    <!-- Dependencies from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Outfit', sans-serif;
            background: radial-gradient(circle at top left, #1e1b4b, #0f172a);
            color: white;
            min-height: 100vh;
        }

        .glass-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6366f1, #a855f7);
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }

        .quiz-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
        }

        .option-btn {
            height: 80px;
            font-size: 1.25rem;
            font-weight: 700;
            border-radius: 12px;
            transition: transform 0.2s;
        }

        .option-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- MATH LOGIC ---
        const generateOptions = (correct) => {
            const options = new Set();
            options.add(correct);
            while (options.size < 4) {
                const offset = Math.floor(Math.random() * 20) - 10;
                const op = correct + (offset === 0 ? 5 : offset);
                if (op >= 0) options.add(op);
            }
            return Array.from(options).sort(() => Math.random() - 0.5);
        };

        const generateQuestion = () => {
            const a1 = Math.floor(Math.random() * 15) + 1;
            const d = Math.floor(Math.random() * 10) + 2;
            const seq = [a1, a1 + d, a1 + d * 2, a1 + d * 3, a1 + d * 4];
            const missingIdx = Math.floor(Math.random() * 5);
            const answer = seq[missingIdx];
            const displaySeq = [...seq];
            displaySeq[missingIdx] = '...';
            return {
                question: `Find the missing number: ${displaySeq.join(', ')}`,
                options: generateOptions(answer),
                answer
            };
        };

        function App() {
            const [myPeer, setMyPeer] = useState(null);
            const [connections, setConnections] = useState([]); // For Host: list of peer connections
            const [hostConn, setHostConn] = useState(null); // For Client: connection to host

            const [username, setUsername] = useState(localStorage.getItem('math_username') || '');
            const [roomCode, setRoomCode] = useState('');
            const [gameState, setGameState] = useState('home'); // home, waiting, playing, leaderboard, gameover
            const [players, setPlayers] = useState([]);
            const [currentQuestion, setCurrentQuestion] = useState(null);
            const [leaderboardData, setLeaderboardData] = useState(null);
            const [gameOverData, setGameOverData] = useState(null);
            const [isHost, setIsHost] = useState(false);
            const [hasAnswered, setHasAnswered] = useState(false);
            const [timer, setTimer] = useState(30);
            const [answersCount, setAnswersCount] = useState({ received: 0, total: 0 });

            // Refs for mutable state shared with effects
            const hostGameRef = useRef({
                questions: [],
                currentIdx: 0,
                players: [],
                answersReceived: 0,
                timerId: null
            });

            // --- PEER INITIALIZATION ---
            useEffect(() => {
                // Auto-fill room code from URL
                const params = new URLSearchParams(window.location.search);
                const r = params.get('room');
                if (r) setRoomCode(r.toUpperCase());
            }, []);

            // --- HOST LOGIC ---
            const createRoom = () => {
                if (!username) return alert('Enter nickname first');
                const peer = new Peer(); // Auto ID generated
                setMyPeer(peer);
                setIsHost(true);

                peer.on('open', (id) => {
                    const shortId = id.substring(0, 5).toUpperCase();
                    // We actually need the full ID for connection, but let's try a custom ID if possible or just use part
                    // Standard PeerJS doesn't guarantee short ID uniqueness, so we'll use a better approach
                    setRoomCode(id); // Use the full Peer ID as room code
                    const initialPlayers = [{ id: 'host', username, score: 0 }];
                    setPlayers(initialPlayers);
                    hostGameRef.current.players = initialPlayers;
                    setGameState('waiting');
                });

                peer.on('connection', (conn) => {
                    conn.on('open', () => {
                        conn.on('data', (data) => handleHostData(conn, data));
                        setConnections(prev => [...prev, conn]);
                    });
                });
            };

            const handleHostData = (conn, data) => {
                const game = hostGameRef.current;

                if (data.type === 'join') {
                    // Check room limit
                    if (game.players.length >= 10) {
                        conn.send({ type: 'error', message: 'Room is full (Max 10)' });
                        return;
                    }
                    const newPlayer = { id: conn.peer, username: data.username, score: 0 };
                    game.players.push(newPlayer);
                    setPlayers([...game.players]);

                    // Broadcast to everyone
                    broadcast({ type: 'player_joined', players: game.players });
                }

                if (data.type === 'submit_answer') {
                    const player = game.players.find(p => p.id === conn.peer);
                    if (player && !player.answered) {
                        player.answered = true;
                        const correct = data.answer === game.questions[game.currentIdx].answer;
                        if (correct) player.score += 1;

                        game.answersReceived++;
                        const progress = { received: game.answersReceived, total: game.players.length };
                        setAnswersCount(progress);
                        broadcast({ type: 'answer_update', ...progress });

                        if (game.answersReceived === game.players.length) {
                            clearTimeout(game.timerId);
                            showLeaderboard();
                        }
                    }
                }
            };

            const broadcast = (data) => {
                connections.forEach(conn => conn.send(data));
                // Host also updates their own UI
                if (data.type === 'player_joined') setPlayers(data.players);
                if (data.type === 'next_question') {
                    setCurrentQuestion(data);
                    setGameState('playing');
                    setHasAnswered(false);
                    setTimer(30);
                    setAnswersCount({ received: 0, total: hostGameRef.current.players.length });
                }
                if (data.type === 'leaderboard') {
                    setLeaderboardData(data);
                    setGameState('leaderboard');
                }
                if (data.type === 'game_over') {
                    setGameOverData(data);
                    setGameState('gameover');
                    confetti({ particleCount: 150, spread: 70, origin: { y: 0.6 } });
                }
                if (data.type === 'answer_update') setAnswersCount({ received: data.received, total: data.total });
            };

            const startGameHost = () => {
                if (players.length < 2) return alert('Need at least 2 players');
                const game = hostGameRef.current;
                game.questions = Array.from({ length: 10 }, () => generateQuestion());
                game.currentIdx = 0;
                sendNextQuestion();
            };

            const sendNextQuestion = () => {
                const game = hostGameRef.current;
                if (game.currentIdx < 10) {
                    game.answersReceived = 0;
                    game.players.forEach(p => p.answered = false);
                    const q = game.questions[game.currentIdx];
                    broadcast({
                        type: 'next_question',
                        question: q.question,
                        options: q.options,
                        number: game.currentIdx + 1,
                        total: 10
                    });

                    game.timerId = setTimeout(showLeaderboard, 30000);
                } else {
                    const sorted = [...game.players].sort((a, b) => b.score - a.score);
                    broadcast({ type: 'game_over', winner: sorted[0], players: sorted });
                }
            };

            const showLeaderboard = () => {
                const game = hostGameRef.current;
                const sorted = [...game.players].sort((a, b) => b.score - a.score);
                broadcast({ type: 'leaderboard', players: sorted });

                game.currentIdx++;
                setTimeout(sendNextQuestion, 5000);
            };

            // --- CLIENT LOGIC ---
            const joinRoom = () => {
                if (!username || !roomCode) return alert('Enter nickname and Room ID');
                const peer = new Peer();
                setMyPeer(peer);
                setIsHost(false);

                peer.on('open', () => {
                    const conn = peer.connect(roomCode);
                    setHostConn(conn);
                    conn.on('open', () => {
                        conn.send({ type: 'join', username });
                    });
                    conn.on('data', handleClientData);
                    conn.on('error', (err) => alert('Connection failed: ' + err));
                });
            };

            const handleClientData = (data) => {
                if (data.type === 'error') alert(data.message);
                if (data.type === 'player_joined') setPlayers(data.players);
                if (data.type === 'next_question') {
                    setCurrentQuestion(data);
                    setGameState('playing');
                    setHasAnswered(false);
                    setTimer(30);
                    setAnswersCount({ received: 0, total: data.total_players || players.length });
                }
                if (data.type === 'answer_update') setAnswersCount({ received: data.received, total: data.total });
                if (data.type === 'leaderboard') {
                    setLeaderboardData(data);
                    setGameState('leaderboard');
                }
                if (data.type === 'game_over') {
                    setGameOverData(data);
                    setGameState('gameover');
                    confetti({ particleCount: 150, spread: 70, origin: { y: 0.6 } });
                }
            };

            const submitAnswer = (option) => {
                if (hasAnswered) return;
                setHasAnswered(true);
                if (isHost) {
                    // Host handles their own answer
                    const game = hostGameRef.current;
                    const player = game.players.find(p => p.id === 'host');
                    player.answered = true;
                    if (option === game.questions[game.currentIdx].answer) player.score += 1;
                    game.answersReceived++;
                    const progress = { received: game.answersReceived, total: game.players.length };
                    setAnswersCount(progress);
                    broadcast({ type: 'answer_update', ...progress });
                    if (game.answersReceived === game.players.length) {
                        clearTimeout(game.timerId);
                        showLeaderboard();
                    }
                } else {
                    hostConn.send({ type: 'submit_answer', answer: option });
                }
            };

            // --- GLOBAL EFFECTS ---
            useEffect(() => {
                localStorage.setItem('math_username', username);
            }, [username]);

            useEffect(() => {
                let interval;
                if (gameState === 'playing' && timer > 0) {
                    interval = setInterval(() => setTimer(prev => prev - 1), 1000);
                }
                return () => clearInterval(interval);
            }, [gameState, timer]);

            // --- UI HELPERS ---
            const copyJoinLink = () => {
                const url = window.location.origin + window.location.pathname + '?room=' + roomCode;
                navigator.clipboard.writeText(url);
                alert('Join link copied!');
            };

            // --- RENDER SCREENS ---
            if (gameState === 'home') return (
                <div className="max-w-md mx-auto mt-32 p-10 glass-card text-center shadow-2xl scale-in">
                    <h1 className="text-5xl font-black mb-10 bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">MATH MASTER</h1>
                    <p className="text-xs mb-4 opacity-50 uppercase tracking-widest font-bold">‚ú® Serverless Multiplayer Edition ‚ú®</p>
                    <input className="w-full bg-white/5 border border-white/10 p-4 rounded-xl mb-4 outline-none focus:border-indigo-500 transition-all font-bold" placeholder="Nickname" value={username} onChange={e => setUsername(e.target.value)} />
                    <button onClick={createRoom} className="w-full btn-primary p-4 rounded-xl font-bold text-lg mb-6 active:scale-95 shadow-lg shadow-indigo-500/20">Create Room</button>
                    <div className="border-t border-white/10 pt-6">
                        <input className="w-full bg-white/5 border border-white/10 p-4 rounded-xl mb-4 outline-none focus:border-indigo-500 font-bold" placeholder="Room ID" value={roomCode} onChange={e => setRoomCode(e.target.value)} />
                        <button onClick={joinRoom} className="w-full border border-white/20 p-4 rounded-xl font-bold hover:bg-white/5 transition-colors active:scale-95">Join Room</button>
                    </div>
                </div>
            );

            if (gameState === 'waiting') return (
                <div className="max-w-2xl mx-auto mt-16 p-8 fade-in">
                    <div className="glass-card p-10 text-center mb-8 relative overflow-hidden">
                        <div className="absolute top-0 left-0 w-full h-1 bg-indigo-500 animate-pulse"></div>
                        <p className="text-indigo-400 font-bold tracking-widest uppercase mb-2">Room ID</p>
                        <h1 className="text-3xl font-black break-all select-all cursor-pointer bg-white/5 p-2 rounded">{roomCode}</h1>
                        <button onClick={copyJoinLink} className="text-indigo-300 text-xs mt-4 font-bold hover:underline opacity-60">üîó Copy Invite Link</button>
                    </div>
                    <div className="glass-card p-8">
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-2xl font-bold">Players ({players.length}/10)</h2>
                            {isHost && <button onClick={startGameHost} className="btn-primary px-8 py-3 rounded-xl font-bold hover:scale-105 active:scale-95">Start Game</button>}
                        </div>
                        <div className="grid grid-cols-2 gap-4">
                            {players.map((p, i) => (
                                <div key={i} className="p-4 bg-white/5 rounded-xl border border-white/5 flex items-center gap-3 slide-up">
                                    <div className={`w-8 h-8 rounded-full flex items-center justify-center font-bold ${p.id === 'host' ? 'bg-indigo-500' : 'bg-purple-500/50'}`}>{p.username[0]}</div>
                                    <span className="font-medium">{p.username} {p.id === 'host' && '(Host)'}</span>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );

            if (gameState === 'playing') return (
                <div className="max-w-4xl mx-auto mt-16 p-6 fade-in">
                    <div className="flex justify-between items-center mb-8">
                        <div className="glass-card px-6 py-2 flex items-center gap-4">
                            <span className="text-indigo-400 font-bold">Q{currentQuestion.number}/10</span>
                            <span className={`font-bold transition-colors ${timer < 5 ? 'text-red-500 animate-ping' : 'text-yellow-400'}`}>‚è± {timer}s</span>
                            <span className="text-green-400 font-bold ml-4">‚úì {answersCount.received}/{answersCount.total} Answered</span>
                        </div>
                        <div className="text-xl font-bold opacity-60">{username}</div>
                    </div>
                    <div className="glass-card p-16 text-center mb-10 min-h-[250px] flex items-center justify-center border-b-8 border-indigo-500 shadow-2xl">
                        <h1 className="text-5xl font-extrabold leading-tight">{currentQuestion.question}</h1>
                    </div>
                    <div className="quiz-grid">
                        {currentQuestion.options.map((opt, i) => (
                            <button key={i} onClick={() => submitAnswer(opt)}
                                disabled={hasAnswered}
                                className={`option-btn shadow-lg ${['bg-rose-500', 'bg-sky-500', 'bg-amber-500', 'bg-emerald-500'][i]} ${hasAnswered ? 'opacity-30 cursor-not-allowed grayscale' : 'hover:scale-[1.03] active:scale-95'}`}>
                                {opt}
                            </button>
                        ))}
                    </div>
                    {hasAnswered && (
                        <div className="text-center mt-8 text-indigo-400 font-bold animate-bounce mt-10">
                            Waiting for other players...
                        </div>
                    )}
                </div>
            );

            if (gameState === 'leaderboard') return (
                <div className="max-w-2xl mx-auto mt-16 p-8 fade-in">
                    <h1 className="text-5xl font-black text-center mb-10 italic tracking-tighter text-indigo-400">SCOREBOARD</h1>
                    <div className="space-y-4">
                        {leaderboardData.players.map((p, i) => (
                            <div key={i} className={`p-6 glass-card flex justify-between items-center transition-all ${i === 0 ? 'border-yellow-500/50 border-2 bg-yellow-500/10 scale-105' : ''}`}>
                                <div className="flex items-center gap-4">
                                    <span className="text-3xl font-black opacity-20">#{i + 1}</span>
                                    <span className="text-2xl font-bold">{p.username}</span>
                                </div>
                                <div className="text-3xl font-black text-indigo-400">{p.score}</div>
                            </div>
                        ))}
                    </div>
                    <div className="text-center mt-12">
                        <div className="inline-block px-8 py-2 bg-indigo-500/20 rounded-full animate-pulse border border-indigo-500/30">
                            <p className="text-indigo-400 font-bold">Preparation for next question...</p>
                        </div>
                    </div>
                </div>
            );

            if (gameState === 'gameover') return (
                <div className="max-w-md mx-auto mt-32 p-10 glass-card text-center scale-in shadow-2xl border-t-8 border-indigo-500">
                    <div className="mb-6 relative">
                        <span className="text-9xl">üëë</span>
                    </div>
                    <h1 className="text-6xl font-black mb-4">VICTORY!</h1>
                    <h2 className="text-3xl font-bold text-yellow-400 mb-2">{gameOverData.winner.username}</h2>
                    <p className="text-5xl font-black mb-10 text-indigo-400">{gameOverData.winner.score} pts</p>
                    <button onClick={() => window.location.reload()} className="w-full btn-primary p-4 rounded-xl font-bold text-lg shadow-lg hover:rotate-1">üè† Play Again</button>
                </div>
            );

            return null;
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>